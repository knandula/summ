//   Provides a parser for symbol expression in GGPerf
//   This code is adapted from a full symbol expression parser
//   I programmed before.
//   Copyright (C) 1997 Jiejun KONG
//   written by Jiejun KONG (jkong@eos.ncsu.edu)
//
//This file is part of KONG's GGPerf.
//
//KONG's GGPerf is free software; you can redistribute it and/or modify
//it under the terms of the GNU General Public License as published by
//the Free Software Foundation; either version 1, or (at your option)
//any later version.
//
//KONG's GGPerf is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with KONG's GGPerf; see the file COPYING.  If not, write to the Free
//Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111, USA.
//

package perfect_hash;

import java.lang.*;
import java.util.*;
import java.io.*;

// Since there are no util for symbol expression parsing in JDK,
// I have to program by myself.
//
// This class is merely for GGPerf usage instead of
// a full version SymExp parser.
// However, this class can be easily extended to parse real
// symbol expression.  This class is actually modified from
// a symbol expression parser I programmed before.
//

/**
  * GGSymExp is a restricted symbol expression parser written in Java.
  * The input is a text string in the format:
  * <PRE>
  *   (StructName ("MemberType" MemberName)
  *               ("MemberType" MemberName)
  *               ...
  *   )
  * </PRE>
  * The reason why the MemberTypes should be enclosed in double quotes
  * is that in Java and C type specification could be composite, as in
  * "char []".  Therefore, I choose double quotes as the delimeter to
  * detect the bound.  In the meanwhile, StructName and MemberNames are
  * merely identifiers, thus blank characters are actually acted as
  * delimeters.
  *
  * <P>
  * The input text string depicts all fields in a composite hash value.
  * This feature is very helpful to hash a key into its composite record.
  * For example,
  * <PRE>
  * (months ("char *" name)
  *         ("int"    number)
  *         ("int"    days)
  *         ("int"    leap_days))
  * </PRE>
  * could be used to generate a perfect hashing function for months.  In
  * the hash value, all months along with their order number, days in
  * month, and leap year days in month are included, as in
  * <PRE>
  * keys           values
  *
  * january   ---> (january,   1, 31, 31)
  * february  ---> (february,  2, 28, 29)
  * march     ---> (march,     3, 31, 31)
  * april     ---> (april,     4, 30, 30)
  * may       ---> (may,       5, 31, 31)
  * june      ---> (june,      6, 30, 30)
  * july      ---> (july,      7, 31, 31)
  * august    ---> (august,    8, 31, 31)
  * september ---> (september, 9, 30, 30)
  * october   ---> (october,  10, 31, 31)
  * november  ---> (november, 11, 30, 30)
  * december  ---> (december, 12, 31, 31)
  * </PRE>
  * where parentheses denote a record.
  * @author Jiejun KONG
  */
public // merely for utilizing `javadoc'
class GGSymExp
{
    /**
      * The symbol expression representing fields of hash values.
      */
    protected Vector sexp = null;

    // the string being parsed
    private String parsing_string = new String();
    // the index of current location being parsed
    private int parsing = 0;

    // current token
    private String token;

    // constants indicating parsing status
    private final static int NORMAL_STRING = 0;
    private final static int NORMAL_IDENTIFIER = 1;
    private final static int ENTER_SEXP = 2;
    private final static int LEAVE_SEXP = 3;
    private final static int END_OF_SEXP = 4;
    private final static int ILLEGAL = 5;
    
    //============
    // Accessor
    //============
    /**
      * Returns the symbol expression after parsing.
      * @return The internal Vector representation of the symbol expression.
      */
    protected Vector getSExp()
    {
        return sexp;
    }

    //============
    // Mutators
    //============
    // You can't set the `sexp'. `sexp' should be generated by parsing.

    //============
    // Constructor
    //============
    /**
      * Creates a new symbol expression from the text representation.
      * @param str The text representation of the symbol expression.
      */
    protected GGSymExp(String str)
    {
        // I assume whitespaces at both ends are useless at all
        str.trim();
        parsing_string = str;
        //System.out.println("Parsing `"+str+"'.");

        if(str.length() > 0)
            parse();
    }

    //============================================================
    // predicates useful in parsing
    //============================================================
    // delimeter predicate of declaration s-exp
    private boolean is_delimeter(char ch)
    {
        if(Character.isWhitespace(ch) ||
           (ch == '(') ||
           (ch == ')'))
            return true;
        return false;
    }

    // identifier heading characters declarator
    // including letters and '_'
    private boolean is_identifier_heading(char ch)
    {
        if(Character.isLetter(ch) ||
           (ch == '$') ||
           (ch == '_'))
            return true;
        return false;
    }
    // identifier trailing characters declarator
    // including letters, digits, and '_'
    private boolean is_identifier_trailing(char ch)
    {
        if(Character.isLetterOrDigit(ch) ||
           (ch == '$') ||
           (ch == '_'))
            return true;
        return false;
    }
    // End Of S-exp
    private boolean is_eos()
    {
        if(parsing >= parsing_string.length())
            return true;
        return false;
    }

    //============================================================
    // reading routines
    //============================================================
    // get next char for parsing
    // with error checking
    private char next_char()
    {
        if(is_eos())
        {
            System.err.println("Parse error: unexpected end of symbol expression.");
            System.exit(-1);
        }
	return parsing_string.charAt(parsing++);
    }
    private void unput_next_char()
    {
        parsing--;
    }

    // skip useless whitespaces
    private void skip_space()
    {
        if(is_eos())
            return;
        while(Character.isWhitespace(next_char()));
        unput_next_char();
    }

    // readin a string "....."
    private boolean read_string()
    {
        int old_parsing = parsing;

        // if it is a string opening at current position, skip "parsing"
        // to the next position of the string closing
        if(next_char() == '"')
        {
            while(true)
            {
                char ch = next_char();

                if(ch == '"')
                    break;
                if(is_eos())
                {
                    System.err.println("Parse error: unexpected end of string.");
                    System.exit(-1);
                }
            }
            token = parsing_string.substring(old_parsing, parsing);
            return true;
        }
        unput_next_char();
        return false;
    }

    // readin an identifier [a-zA-Z_][a-ZA-Z0-9_$]*
    private boolean read_identifier()
    {
        int old_parsing = parsing;

        if(is_identifier_heading(next_char()))
        {
            while(true)
            {
                char ch = next_char();

                if(is_eos())
                    break;
                if(!is_identifier_trailing(ch))
                {
                    unput_next_char();
                    break;
                }
            }
            token = parsing_string.substring(old_parsing, parsing);
            return true;
        }
        unput_next_char();
        return false;
    }

    // the token getter, naming after YACC's scheme
    private int yylex()
    {
	if(is_eos())
	    return END_OF_SEXP;

	// first let's goto meaningful part
	skip_space();

	if(is_eos())
	    return END_OF_SEXP;

	char ch = next_char();

	// enter a sub-s-exp
	if(ch == '(')
	    return ENTER_SEXP;

	// leave a sub-s-exp
	if(ch == ')')
	    return LEAVE_SEXP;

	// then, a normal token
        unput_next_char();
        // a string?
	if(read_string())
	{
            if(is_eos())
                return NORMAL_STRING;

            ch = next_char();
	    if(is_delimeter(ch))
            {
                unput_next_char();
		return NORMAL_STRING;
            }
	    // something wrong after the string
	    else
	    {
		System.err.println("Parse error: redundant staffs after a string.");
		System.exit(-1);
	    }
	}

        // an identifier?
	if(read_identifier())
	{
            if(is_eos())
                return NORMAL_IDENTIFIER;

            ch = next_char();
	    if(is_delimeter(ch))
            {
                unput_next_char();
		return NORMAL_IDENTIFIER;
	    }
	    else
	    {
		System.err.println("Parse error: redundant staffs after an identifier.");
		System.exit(-1);
	    }
	}
	System.err.println("Parse error: illegal token.");
	return ILLEGAL;
    }

    // the parser
    // turn text representation into internal vector representation
    private void parse()
    {
        int t = yylex();
        if(t != ENTER_SEXP)
        {
            System.err.println("Parse error: `(' expected.");
            System.exit(-1);
        }
        sexp = new Vector();

        t = yylex();
        if(t != NORMAL_IDENTIFIER)
        {
            System.err.println("Parse error: structure name expected.");
            System.exit(-1);
        }
        sexp.addElement(token);

        while(true)
        {
            Vector member = new Vector();

            t = yylex();
            if(t == LEAVE_SEXP)
                break;
            else if(t != ENTER_SEXP)
            {
                System.err.println("Parse error: `(' expected.");
                System.exit(-1);
            }

            t = yylex();
	    if(t != NORMAL_STRING)
            {
                System.err.println("Parse error: type string expected.");
                System.exit(-1);
            }
            token = token.substring(1, token.length()-1);
            if(token.length() == 0)
            {
                System.err.println("Parse error: empty type string.");
                System.exit(-1);
            }
            member.addElement(token);

            t = yylex();
	    if(t != NORMAL_IDENTIFIER)
            {
                System.err.println("Parse error: identifer expected.");
                System.exit(-1);
            }
            member.addElement(token);

            t = yylex();
	    if(t != LEAVE_SEXP)
            {
                System.err.println("Parse error: `)' expected.");
                System.exit(-1);
            }

            sexp.addElement(member);
        }

        t = yylex();
        if(t != END_OF_SEXP)
        {
            System.err.println("Parse error: redundant stuff after symbol expression.");
            System.exit(-1);
        }
    }

    // the debugging routine
    static void print_sexp(Object vec)
    {
        try
        {
            // a sub-vector
            if(vec.getClass() == Class.forName("java.util.Vector"))
            {
                Enumeration vec_enum = ((Vector)vec).elements();

                System.out.print("( ");
                while(vec_enum.hasMoreElements())
                    print_sexp(vec_enum.nextElement());
                System.out.print(") ");
            }
            else
                System.out.print(vec + " ");
        }
        catch (ClassNotFoundException e) {}
    }

    // this main function is just for testing
    private static void main(String[] args)
    {
        GGSymExp test = new GGSymExp("(resword (\"char *\" name)	 (\"short\" token)(\"enum rid\" rid))");
        GGSymExp.print_sexp(test.sexp);
    }
}
